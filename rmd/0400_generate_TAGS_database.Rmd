---
title: "`r knitr::current_input()`"
date:   "`r format(Sys.Date(), '%d_%b_%Y')`" 
TAGS:  yaml,tags,lapply examples,utils,data.table
---



## Definitions 
  
  * `files` = char[] of all files to be process for TAGS
  * `headers` = named list of yaml, one element for each file in files. Content
    includes all yaml specifications, include  if exits.
  * `TAGS` = named list, each element has name = its file name; contents are
    chr[1] of contents of `TAGS:`  ( `tag1,tag2,tag3...` )


#  ==========
#  load_all()
#   Be sure in vim and R in same wd
#    USE   ,rd  setwd("~/code/publish_project/rmd/")
```{r for_real}
load_all()
library(data.table)
library(rmarkdown)
library(TAGS)
library(purrr)


# FOR testing ##########
dir = "~/code/try_things_here/rmd"

```

```{r begin}

{
x  <- 3
begin  <- Sys.time()
rmd_pattern  <- '[.][Rr](md|markdown)$'
md_pattern  <- '[.][Rr]?(md|markdown)$'

files  <- TAGS::get_files(path = dir, pattern = rmd_pattern)
head(files)


# For each file, extract yaml header into unnamed list:
# each element of headers holds a char[], yaml lines of each file.
headers  <- lapply(files, TAGS::get_header)
headers[1]


# be sure each elment knows its file name
names(headers)  <- files 
headers

get_t  <- function(e) {
  if (!is.null(e$TAGS)) { return(e$TAGS)
  } else {
    return(NA)
  }
}


{  #PURRR
# in purrr then DONE!
if (F) {
TAGS  <- purrr::map_chr(headers, get_t)
TAGS

#  OR
if (F) purrr::map_chr(headers[1:3], "TAGS")
}

{ IN BASE:
# in base:   return named char[], with NA if file has no TAGS line
# default: unlist removes names 
TAGS <- unlist(lapply(headers, get_t), use.names =T)
TAGS
# TAGS  <- lapply(headers, get_TAGS)
}

end  <- Sys.time()
print(end - begin)
}
TAGS
head(TAGS)
```



```{r data_table}

dt  <- data.table(files = basename(files),
                  TAGS = TAGS)

dt

head(dt, n=10L)
# 
```
```{r}
x  <- c(a = "1", b="2")
x
dt  <- data.table(name = names(x), x)
dt

```



```{r process}

# Step 1, remove NULL
f  <- function(e) ifelse(is.null(e), return(NA), return(e))
dt  <- dt[,.(files, TAGS = lapply(TAGS, f)) ]
dt

# Step 2, NA_character_
# Step 2  use NA_character_ version of NA
#base::strsplit() works with NA_character_, but not NA
f  <- function(e) ifelse(is.character(e),return(e), return(c(NA_character_)))
dt  <- dt[, .(files, TAGS = lapply(TAGS, f)) ]
dt

# Step 3, split and normalize
split_up  <- function(e) base::strsplit(e, split="[,]")
dt  <- dt[, .(TAGS = unlist(lapply(TAGS, split_up) )) , by=files]
head(dt, n=100L)
dt[, .N]

```


```{r save_to_file  }
file_name  <- paste0("TAGS_", format(Sys.Date(), "%d%b%Y"))
file_name

# For coding, R internals:
# save/load save one or more objects into environment

# For users:
# saveRDS/readRDS save ONE object, possible retrieve in different name
saveRDS(dt, file_name)

# retrieve
lines  <- readRDS(file_name)
lines

```
```{r order}
dt[!is.na(TAGS), sort(TAGS)]
dt[!is.na(TAGS), by=file] 
```




```{r render, eval=F, include=F}


## GOOD PRACTICE:
#  Refer to files relative to project root, which should remain as working dir.
#  So why using `here` ?

file  <-"generate_TAGS.Rmd"
file  <- here("rmd", file)
file

# debugging
options(tinytex.verbose = TRUE)
## Want github to display nicely rendered output?
##  *  include md_format
#   *  include output_dir = "out"
#   *  if .gitignore balks,  then add !out/**   to close .github
rmarkdown::render(file,
                  #output_format = "pdf_document",
                  #output_format = "html_document",
                  output_format=c("html_document",    # if want both
                                  "md_document"),
                  #output_dir = "out",
                  output_file = "out")

```




